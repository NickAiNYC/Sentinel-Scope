"""Vision-to-Compliance Bridge: Main orchestrator for the compliance detection pipeline."""
import uuid
from datetime import datetime
from typing import Any, List, Optional

from packages.sentinel.entity_matcher import DatabaseInterface, EntityMatcher
from packages.sentinel.models import ComplianceGap, DecisionProof, DetectedEntity
from packages.sentinel.outreach_agent import NotificationInterface, OutreachAgent
from packages.sentinel.vision_agent import VisionAgent


class VisionComplianceBridge:
    """
    Main orchestrator that:
    1. Processes site-cam frames with VisionAgent
    2. Checks compliance with EntityMatcher
    3. Detects gaps and triggers OutreachAgent notifications
    4. Generates DecisionProof for audit trail
    """
    
    def __init__(
        self,
        vision_api_key: str,
        database_interface: DatabaseInterface | None = None,
        notification_service: NotificationInterface | None = None,
        supervisor_contact: str = "supervisor@example.com"
    ):
        """
        Initialize the Vision-to-Compliance bridge.
        
        Args:
            vision_api_key: API key for vision model
            database_interface: Database interface for compliance queries
            notification_service: Notification service for outreach
            supervisor_contact: Supervisor contact for notifications
        """
        self.vision_agent = VisionAgent(api_key=vision_api_key)
        self.entity_matcher = EntityMatcher(database_interface=database_interface)
        self.outreach_agent = OutreachAgent(
            notification_service=notification_service,
            supervisor_contact=supervisor_contact
        )
        self.decision_proofs: list[DecisionProof] = []
    
    def process_frame(
        self, 
        frame_source: str | Any,
        screenshot_url: str,
        location: str = "Unknown"
    ) -> list[DecisionProof]:
        """
        Process a single frame through the complete compliance pipeline.
        
        Args:
            frame_source: Frame image path or file-like object
            screenshot_url: URL or path for the screenshot (audit trail)
            location: Site location identifier
            
        Returns:
            List of DecisionProof objects generated
        """
        proofs = []
        
        # Step 1: Detect entities with VisionAgent
        entities = self.vision_agent.process_frame(frame_source, location)
        
        # Step 2-4: For each entity, check compliance, detect gaps, notify, and create proof
        for entity in entities:
            # Check compliance status
            compliance_status = self.entity_matcher.check_compliance(entity)
            
            # Detect compliance gaps
            gap = self.entity_matcher.detect_gaps(entity, compliance_status)
            
            # Trigger notification if gap found
            notification_sent = False
            if gap:
                notification_sent = self.outreach_agent.notify_gap(gap)
            
            # Create DecisionProof for audit trail
            proof = DecisionProof(
                proof_id=str(uuid.uuid4()),
                entity=entity,
                compliance_status=compliance_status,
                gap=gap,
                screenshot_url=screenshot_url,
                timestamp=datetime.now(),
                notification_sent=notification_sent,
                metadata={
                    'location': location,
                    'frame_source': str(frame_source),
                    'processing_pipeline': 'VisionComplianceBridge',
                }
            )
            
            proofs.append(proof)
            self.decision_proofs.append(proof)
        
        return proofs
    
    def process_frames_batch(
        self,
        frame_sources: list[str | Any],
        screenshot_urls: list[str],
        location: str = "Unknown"
    ) -> list[DecisionProof]:
        """
        Process multiple frames in batch.
        
        Args:
            frame_sources: List of frame paths or file-like objects
            screenshot_urls: List of screenshot URLs corresponding to frames
            location: Site location identifier
            
        Returns:
            Combined list of DecisionProof objects
        """
        all_proofs = []
        
        for frame_source, screenshot_url in zip(frame_sources, screenshot_urls):
            proofs = self.process_frame(frame_source, screenshot_url, location)
            all_proofs.extend(proofs)
        
        return all_proofs
    
    def get_all_proofs(self) -> list[DecisionProof]:
        """
        Get all DecisionProofs generated by this bridge instance.
        
        Returns:
            List of all DecisionProof objects
        """
        return self.decision_proofs.copy()
    
    def get_proofs_with_gaps(self) -> list[DecisionProof]:
        """
        Get only DecisionProofs that have detected compliance gaps.
        
        Returns:
            List of DecisionProof objects with gaps
        """
        return [proof for proof in self.decision_proofs if proof.gap is not None]
    
    def get_critical_proofs(self) -> list[DecisionProof]:
        """
        Get DecisionProofs with critical severity gaps.
        
        Returns:
            List of DecisionProof objects with critical gaps
        """
        return [
            proof for proof in self.decision_proofs 
            if proof.gap and proof.gap.severity == "Critical"
        ]
    
    def export_proofs_to_json(self) -> list[dict]:
        """
        Export all DecisionProofs to JSON-serializable format.
        
        Note: Uses Pydantic v2 model_dump with mode='json'.
        Requires Pydantic>=2.0.
        
        Returns:
            List of proof dictionaries
        """
        return [proof.model_dump(mode='json') for proof in self.decision_proofs]
    
    def clear_proofs(self):
        """Clear all stored DecisionProofs."""
        self.decision_proofs.clear()
    
    def generate_audit_report(self) -> dict:
        """
        Generate a comprehensive audit report.
        
        Returns:
            Dictionary with audit statistics and data
        """
        total_proofs = len(self.decision_proofs)
        proofs_with_gaps = len(self.get_proofs_with_gaps())
        critical_proofs = len(self.get_critical_proofs())
        
        # Count by entity type
        entity_counts = {}
        for proof in self.decision_proofs:
            entity_type = proof.entity.entity_type
            entity_counts[entity_type] = entity_counts.get(entity_type, 0) + 1
        
        # Count by gap type
        gap_counts = {}
        for proof in self.get_proofs_with_gaps():
            if proof.gap:
                gap_type = proof.gap.gap_type
                gap_counts[gap_type] = gap_counts.get(gap_type, 0) + 1
        
        return {
            'report_generated_at': datetime.now().isoformat(),
            'total_detections': total_proofs,
            'compliant_detections': total_proofs - proofs_with_gaps,
            'gaps_detected': proofs_with_gaps,
            'critical_gaps': critical_proofs,
            'entity_type_breakdown': entity_counts,
            'gap_type_breakdown': gap_counts,
            'notifications_sent': sum(1 for p in self.decision_proofs if p.notification_sent),
            'proofs': self.export_proofs_to_json()
        }
